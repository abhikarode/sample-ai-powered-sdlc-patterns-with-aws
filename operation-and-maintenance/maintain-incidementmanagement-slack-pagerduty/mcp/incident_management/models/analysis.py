"""
AI analysis result data models.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import List, Dict, Any, Optional


class RiskLevel(Enum):
    """Risk assessment levels for incidents"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    MINIMAL = "minimal"


@dataclass
class AnalysisResult:
    """
    Result of AI-powered incident analysis.
    
    Contains insights, root cause analysis, and recommendations
    generated by the AI analyzer.
    """
    incident_id: str
    root_causes: List[str]
    confidence_score: float  # 0.0 to 1.0
    affected_components: List[str]
    suggested_actions: List[str]
    similar_incidents: List[str]
    risk_assessment: RiskLevel
    estimated_resolution_time: timedelta
    analysis_timestamp: datetime = field(default_factory=datetime.utcnow)
    analyzer_version: str = "1.0.0"
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate analysis result data"""
        if not 0.0 <= self.confidence_score <= 1.0:
            raise ValueError("Confidence score must be between 0.0 and 1.0")
        
        if not self.analysis_timestamp:
            self.analysis_timestamp = datetime.utcnow()
    
    def add_root_cause(self, cause: str) -> None:
        """Add a root cause to the analysis"""
        if cause not in self.root_causes:
            self.root_causes.append(cause)
    
    def add_suggested_action(self, action: str) -> None:
        """Add a suggested action to the analysis"""
        if action not in self.suggested_actions:
            self.suggested_actions.append(action)
    
    def add_similar_incident(self, incident_id: str) -> None:
        """Add a similar incident reference"""
        if incident_id not in self.similar_incidents:
            self.similar_incidents.append(incident_id)
    
    def update_confidence(self, new_score: float) -> None:
        """Update confidence score with validation"""
        if not 0.0 <= new_score <= 1.0:
            raise ValueError("Confidence score must be between 0.0 and 1.0")
        self.confidence_score = new_score
    
    def is_high_confidence(self, threshold: float = 0.8) -> bool:
        """Check if analysis has high confidence"""
        return self.confidence_score >= threshold
    
    def get_priority_actions(self, max_count: int = 3) -> List[str]:
        """Get top priority suggested actions"""
        return self.suggested_actions[:max_count]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert analysis result to dictionary"""
        return {
            'incident_id': self.incident_id,
            'root_causes': self.root_causes,
            'confidence_score': self.confidence_score,
            'affected_components': self.affected_components,
            'suggested_actions': self.suggested_actions,
            'similar_incidents': self.similar_incidents,
            'risk_assessment': self.risk_assessment.value,
            'estimated_resolution_time': self.estimated_resolution_time.total_seconds(),
            'analysis_timestamp': self.analysis_timestamp.isoformat(),
            'analyzer_version': self.analyzer_version,
            'metadata': self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AnalysisResult':
        """Create analysis result from dictionary"""
        risk_assessment = RiskLevel(data['risk_assessment'])
        estimated_resolution_time = timedelta(seconds=data['estimated_resolution_time'])
        analysis_timestamp = datetime.fromisoformat(data['analysis_timestamp'])
        
        return cls(
            incident_id=data['incident_id'],
            root_causes=data['root_causes'],
            confidence_score=data['confidence_score'],
            affected_components=data['affected_components'],
            suggested_actions=data['suggested_actions'],
            similar_incidents=data['similar_incidents'],
            risk_assessment=risk_assessment,
            estimated_resolution_time=estimated_resolution_time,
            analysis_timestamp=analysis_timestamp,
            analyzer_version=data.get('analyzer_version', '1.0.0'),
            metadata=data.get('metadata', {})
        )
    
    def __str__(self) -> str:
        """String representation of analysis result"""
        return (f"AnalysisResult(incident={self.incident_id}, "
                f"confidence={self.confidence_score:.2f}, "
                f"risk={self.risk_assessment.value})")


@dataclass
class IncidentCorrelation:
    """
    Represents correlation between multiple incidents.
    
    Used to group related incidents and reduce alert fatigue.
    """
    correlation_id: str
    primary_incident_id: str
    related_incident_ids: List[str]
    correlation_score: float  # 0.0 to 1.0
    correlation_factors: List[str]
    created_at: datetime = field(default_factory=datetime.utcnow)
    
    def __post_init__(self):
        """Validate correlation data"""
        if not 0.0 <= self.correlation_score <= 1.0:
            raise ValueError("Correlation score must be between 0.0 and 1.0")
    
    def add_related_incident(self, incident_id: str) -> None:
        """Add a related incident to the correlation"""
        if incident_id not in self.related_incident_ids:
            self.related_incident_ids.append(incident_id)
    
    def is_strong_correlation(self, threshold: float = 0.7) -> bool:
        """Check if correlation is strong"""
        return self.correlation_score >= threshold
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert correlation to dictionary"""
        return {
            'correlation_id': self.correlation_id,
            'primary_incident_id': self.primary_incident_id,
            'related_incident_ids': self.related_incident_ids,
            'correlation_score': self.correlation_score,
            'correlation_factors': self.correlation_factors,
            'created_at': self.created_at.isoformat()
        }